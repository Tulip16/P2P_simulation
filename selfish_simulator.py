import math
import numpy as np
from queue import PriorityQueue
import random
from treelib import Node, Tree
import time as sleep_time 

MAX_BLK_SIZE = 1000

# concatenates the pid with the block number generated by that peer 
def generate_b_id(p_id, b_id):
    str_p_id = str(p_id)
    str_b_id = str(b_id)
    digits1 = len(str_p_id)
    digits2 = len(str_b_id)
    zer1 = "0"*(6 - digits1)
    zer2 = "0"*(6 - digits2)
    strng = zer1+str_p_id+zer2+str_b_id
    return strng

# concatenates the pid with the transaction number generated by that peer 
def generate_t_id(p_id, t_id):
    str_p_id = str(p_id)
    str_t_id = str(t_id)
    digits1 = len(str_p_id)
    digits2 = len(str_t_id)
    zer1 = "0"*(6 - digits1)
    zer2 = "0"*(6 - digits2)
    strng = zer1+str_p_id+zer2+str_t_id
    return strng

# sampling from the exp dist with mean Tk to deicde POW time for peer k
def generate_POW_time(Tk):
    return np.random.exponential(Tk)

# for compressed visualisation
class CompressNode(object):
    def __init__(self):
        self.node = "*"

# contains all the data of the P2P network
class P2P(object):
    def __init__(self, num_peers, Tx, Tk, Tk_selfish, num_selfish):
        self.transaction_map = {} # t_id to transaction info mapping
        self.block_map = {} # b_id to block info mapping
        self.num_peers = num_peers # number of peers in the network
        self.peers = [] # p_id to peer info mapping
        self.genesis_block = None # created and set for all peers at the start of the simulation
        self.check1 = False
        self.check2 = False
        self.num_selfish = num_selfish

        num_fast = math.floor((num_peers-num_selfish)*50/100)
        count_fast = 0
        self.Tx = Tx

        # adding slow and fast peers to the network after checking if they are selfish
        for i in range(1, num_peers-num_selfish+1):
            if count_fast<num_fast:
                self.peers.append(self.Peer(i,'fast', self, False, Tk[i-1]))
            else:
                self.peers.append(self.Peer(i,'slow', self, False, Tk[i-1]))
            count_fast += 1

        for i in range(num_peers-num_selfish+1, num_peers+1):
            self.peers.append(self.Peer(i,'fast', self, True, Tk_selfish[i-(num_peers-num_selfish+1)]))
                
        # setting the connectivity graph for the network
        self.peer_graph = self.Graph(self)
        for peer in self.peers:
            self.peer_graph.add_vertex(peer.p_id, peer.fast_slow)
            
        self.adj_mat, self.selfish_adj_mat = self.peer_graph.generate_random_graph()

        # tree structures for simulation visualisation
        self.visual_trees = []
        for i in range(num_peers):
            self.visual_trees.append(Tree())

        self.selfish_visual_trees = []
        for i in range(num_peers):
            self.selfish_visual_trees.append(Tree())

    
    # creates genesis block with id = 0*12, adds to the start of block chain trees of all peers
    def genesis(self):
        for i in range(self.num_peers):
            self.visual_trees[i].create_node("(b_id: 000000000000, time: 0)", "000000000000", data=CompressNode())
            self.selfish_visual_trees[i].create_node("(b_id: 000000000000, time: 0)", "000000000000", data=CompressNode())
        
        self.genesis_block = self.Block([], "000000000000", -1, 0, False)
        self.block_map["000000000000"] = self.genesis_block
        # trigger block creation at all peers
        for peer in self.peers:
            event = self.Event("cblk", -1, 0)
            peer.add_event(1, event)

    # runs the simulation for the p2p network
    def run(self, sim_time, check1, check2):
        self.check1 = check1
        self.check2 = check2
        self.genesis()
        time = 0
        clk_time = 1
        for i in range(sim_time):
            for peer in self.peers:
                peer.handle_events(time)
            time += clk_time
            #sleep_time.sleep(0.001)

    # contains transaction info
    class Transaction(object):
        def __init__(self, t_id, payer, receiver, amt):
            self.payer = payer
            self.receiver = receiver
            self.amt = amt
            self.t_id = t_id
            self.txn_string = "%s: pID: %d pays pID: %d %d coins"%(t_id, payer, receiver, amt)
            
        
    # contains block info
    class Block(object):
        def __init__(self, txns, b_id, prev_b_id, miner, hidden):
            self.prev_b_id = prev_b_id
            self.txns = txns
            self.b_id = b_id
            self.miner = miner
            self.hidden = hidden

    # contains node metadata for all blocks in the blockchain tree for each peer
    # each peer would have overlapping blocks but their metadata would be different, hence the need for this separate class
    class BlockTree:
        def __init__(self, b_id, length, peer):
            self.peer = peer # the peer in whose blockchain tree this node appears
            # children nodes
            self.children = []
            self.b_id = b_id            
            self.length = length # length of the branch ending at this block node        
            self.accounts = [] # account balance for each peer at this block node as per the chain 
            # to which this block node belongs in the block chain tree   


    class Event(object):
        def __init__(self, typ, data, sender):
            self.type = typ # type of the event
            self.data = data  # event metadata - bid/ tid etc
            self.sender = sender # blk/txn sender

        # defined for allowing ordering of time, event tuples in the events queue for each peer
        def __gt__(self, other):
            return False

    # contains peer info
    class Peer(object):
        def __init__(self, p_id, fast_slow, p2p, selfish, Tk):
            self.p_id = p_id
            self.pending_txs = [] # txns received or created but not yet added in any block 
            self.events = PriorityQueue() # events queue
            self.next_t = 0 # mantains number of txns generated so far for this peer
            self.next_b = 0 # mantains number of blocks generated so far for this peer
            self.p2p = p2p # p2p network to which this peer belongs
            self.fast_slow = fast_slow # fast or slow
            self.block_tree_root = self.p2p.BlockTree("000000000000", 1, self) # root of the block chain tree at this peer
            self.selfish = selfish
            self.Tk = Tk
            self.latest_alert_b_id = None
            # root of the hidden tree for a selfish peer starting at the shared point b/w hidden and common trees
            if self.selfish:
                self.selfish_block_tree_root = self.p2p.BlockTree("000000000000", 1, self) 
            else:
                self.selfish_block_tree_root = None

            # setting default number of bitcoins with the peers to 0 in the beginning
            for peer_num in range(self.p2p.num_peers):
                self.block_tree_root.accounts.append(0)
                if self.selfish:
                    self.selfish_block_tree_root.accounts.append(0)
            # !!
            self.longest = ["000000000000"] # list of bids of blocks at the end of longest chains of the block tree at this peer
            if self.selfish:
                self.selfish_longest = ["000000000000"]
            else:
                self.selfish_longest = None
            self.block_node_map = {} # block id to block node mapping for this peer (different for different peers
            # as the blcok chain tree for each node differs)
            self.block_node_map["000000000000"] = self.block_tree_root # setting the root node to contain the genesis block

            self.selfish_block_node_map = {}
            if self.selfish:
                self.selfish_block_node_map["000000000000"] = self.selfish_block_tree_root


            file = open("peer %d"%(self.p_id), "w")
            file.write(f"{'blockID' : <10}{'depth' : ^10}{'time_of_arrival': ^10}{'parent_blockID' : >15}\n")
            file.close()
 
            # schedule first transaction generation at some time from now (from time = 0)
            self.add_next_transaction(0)

        # inserts a block node to the block chain tree of this peer and returns if it is was added to the single current longest chain or
        def tree_insert(self, b_id, time):
            prev_b_id = self.p2p.block_map[b_id].prev_b_id # bid of the block to which thid block has to be attached
            miner = self.p2p.block_map[b_id].miner # pid of the miner of this block

            # adding the block to the tree structure for visualization
            node_val = "(b_id: %s, time: %f)" % (b_id, time)
            self.p2p.visual_trees[self.p_id-1].create_node(node_val, b_id, parent=prev_b_id, data=CompressNode())

            is_longest = False # true if the addition of this block creates the longest chain
            parent_block_node = self.block_node_map[prev_b_id]
            block_tree_node = self.p2p.BlockTree(b_id, parent_block_node.length+1, self)

            # updating the balance accounts for the chain of the block tree to which this node was inserted
            block_tree_node.accounts = parent_block_node.accounts
            for txn in self.p2p.block_map[b_id].txns:
                payer = self.p2p.transaction_map[txn].payer
                receiver = self.p2p.transaction_map[txn].receiver
                amt = self.p2p.transaction_map[txn].amt
                block_tree_node.accounts[payer-1] = parent_block_node.accounts[payer-1] - amt
                block_tree_node.accounts[receiver-1] = parent_block_node.accounts[receiver-1] + amt

            # adding mining fee
            block_tree_node.accounts[miner-1] += 50

            self.block_node_map[b_id] = block_tree_node
            # add the block to the children of its previous block
            parent_block_node.children.append(block_tree_node)

            longest_length = self.block_node_map[self.longest[0]].length # length of the longest chain in the tree
            if longest_length < block_tree_node.length:
                self.longest = [b_id] # updated the longest chains list if new longest chain formed
                is_longest = True # set if the new block creates the longest chain
            # !! to be deleted ?
            if longest_length == block_tree_node.length:
                self.longest.append(b_id)
            # !!

            file = open("peer %d"%(self.p_id), "a")
            file.write(f"{b_id : <10}{block_tree_node.length : ^10}{time : ^10}{prev_b_id : >15}\n")
            file.close()

            return is_longest

        # inserts a block node to the selfish block chain tree of this peer and returns if it is was added to the single current longest chain or
        def selfish_tree_insert(self, b_id, time):
            prev_b_id = self.p2p.block_map[b_id].prev_b_id # bid of the block to which thid block has to be attached
            miner = self.p2p.block_map[b_id].miner # pid of the miner of this block

            # adding the block to the tree structure for visualization
            node_val = "(b_id: %s, time: %f)" % (b_id, time)
            self.p2p.selfish_visual_trees[self.p_id-1].create_node(node_val, b_id, parent=prev_b_id, data=CompressNode())

            is_longest = False # true if the addition of this block creates the longest chain
            parent_block_node = self.selfish_block_node_map[prev_b_id]
            block_tree_node = self.p2p.BlockTree(b_id, parent_block_node.length+1, self)

            # updating the balance accounts for the chain of the block tree to which this node was inserted
            block_tree_node.accounts = parent_block_node.accounts
            for txn in self.p2p.block_map[b_id].txns:
                payer = self.p2p.transaction_map[txn].payer
                receiver = self.p2p.transaction_map[txn].receiver
                amt = self.p2p.transaction_map[txn].amt
                block_tree_node.accounts[payer-1] = parent_block_node.accounts[payer-1] - amt
                block_tree_node.accounts[receiver-1] = parent_block_node.accounts[receiver-1] + amt

            # adding mining fee
            block_tree_node.accounts[miner-1] += 50

            self.selfish_block_node_map[b_id] = block_tree_node
            # add the block to the children of its previous block
            parent_block_node.children.append(block_tree_node)

            longest_length = self.selfish_block_node_map[self.selfish_longest[0]].length # length of the longest chain in the tree
            if longest_length < block_tree_node.length:
                self.selfish_longest = [b_id] # updated the longest chains list if new longest chain formed
                is_longest = True # set if the new block creates the longest chain
            # !! to be deleted ?
            if longest_length == block_tree_node.length:
                self.selfish_longest.append(b_id)
            # !!

            file = open("peer %d"%(self.p_id), "a")
            file.write(f"{b_id : <10}{block_tree_node.length : ^10}{time : ^10}{prev_b_id : >15}\n")
            file.close()

            return is_longest

        # generates the next transaction time by sampling the delay from the last txn from an exp dist
        def add_next_transaction(self, time):
            self.next_t += 1
            t_id = generate_t_id(self.p_id, self.next_t)
            next_time = time + np.random.exponential(self.p2p.Tx)
            self.events.put((next_time, self.p2p.Event("gtxn",t_id, self.p_id)))

        # adds an event to the events queue, used when one event for one peer generates another one for another peer
        def add_event(self, time, event):
            self.events.put((time, event))

        def generate_txn(self, t_id, time):
            if self.p2p.check1 and t_id=="000001000001":
                print("pID: %d generated txn with TxnID: %s at time: %f" %
                      (self.p_id, t_id, time))
            # choose a random peer
            peer_num = 1 + np.random.randint(self.p2p.num_peers)
            if(peer_num == self.p_id): # if self chosen, update
                if(self.p_id == 1):
                    peer_num += 1
                else:
                    peer_num -= 1
            # !! change?
            amt = np.random.uniform(1, 100, 1)
            # !!
            txn = self.p2p.Transaction(t_id, self.p_id, peer_num, amt)
            self.p2p.transaction_map[txn.t_id] = txn

            if self.p2p.check1 and t_id=="000001000001":
                print(txn.txn_string)
            # receive own txn
            self.receive_txn(t_id, time, self.p_id)

            # set next txn time for this peer
            self.add_next_transaction(time)

        def receive_txn(self, t_id, time, sender):
            if t_id not in self.pending_txs:
                if self.p2p.check1 and t_id=="000001000001":
                    print("pID: %d received txn with TxnID: %s at time: %f from pID: %d" %
                          (self.p_id, t_id, time, sender))
                self.pending_txs.append(t_id)
                for i in range(self.p2p.num_peers):
                    if self.p2p.adj_mat[self.p_id-1][i]>0 and i+1 != sender:
                        event = self.p2p.Event("rtxn", t_id, self.p_id)
                        if(self.p2p.peers[i].fast_slow==1 and self.fast_slow==1):
                            cij = 100
                        else:
                            cij = 5
                        txn_sz = 8
                        delay = time+(self.p2p.adj_mat[self.p_id-1][i]+(txn_sz/cij)+np.random.exponential(96/cij))
                        self.p2p.peers[i].add_event(delay, event)

        def receive_block(self, b_id, time, sender):
            # add immediate self receive_alert if a selfish one receives a verified honest block
            block = self.p2p.block_map[b_id]

            if not block.hidden:
                # check if parent exists, return false otherwise
                try:
                    parent_block_node = self.block_node_map[block.prev_b_id]
                except:
                    if self.p2p.check2 and b_id.startswith("000004"):
                        print("Previous block %s has not arrived at p_id: %d!"%(block.prev_b_id, self.p_id))
                    return

                for child in parent_block_node.children:
                    if(child.b_id == b_id):
                        return

                if self.p2p.check2 and b_id.startswith("000004"):
                    print("pID: %d received block with BlkID: %s at time: %f from pID: %d" %
                          (self.p_id, b_id, time, sender))

                if self.verify_block(b_id, time): # if block is verified
                    if self.selfish and not self.p2p.peers[block.miner-1].selfish:
                        # print("pid: %d received a block by honest miner %d"%(self.p_id, block.miner))
                        lead = self.selfish_block_node_map[self.selfish_longest[0]].length - self.block_node_map[self.longest[0]].length  #lead od selfish miner as compared to honest miners     
                        self.receive_alert(-1, time, b_id, lead, 0)

                    if not self.selfish:
                        # remove block txns from pending list
                        for txn in self.p2p.block_map[b_id].txns:
                            self.rem_txn(txn)

                    # insert the  block node into the tree              
                    is_longest = self.tree_insert(b_id, time)

                    # forward the block to neighbours
                    for i in range(self.p2p.num_peers):
                        if self.p2p.adj_mat[self.p_id-1][i]>0 and i+1 != sender:
                            event = self.p2p.Event("rblk", b_id, self.p_id)
                            if(self.p2p.peers[i].fast_slow==1 and self.fast_slow==1):
                                cij = 100
                            else:
                                cij = 5
                            blk_size = max(8*len(self.p2p.block_map[b_id].txns), 8)
                            delay = time+(self.p2p.adj_mat[self.p_id-1][i]+(blk_size/cij)+np.random.exponential(96/cij))
                            self.p2p.peers[i].add_event(delay, event)
                    # start mining if longest chain formed for an honest miner
                    if is_longest and not self.selfish:
                        self.create_block(time)
                else:
                    if self.p2p.check2 and b_id.startswith("000004"):
                        print("INVALID BLOCK!!")
                    pass
            else:
                if not self.selfish:
                    return
                # check if parent exists, return false otherwise
                try:
                    parent_block_node = self.selfish_block_node_map[block.prev_b_id]
                except:
                    if self.p2p.check2 and b_id.startswith("000004"):
                        print("Previous block %s has not arrived at p_id: %d!"%(block.prev_b_id, self.p_id))
                    return

                for child in parent_block_node.children:
                    if(child.b_id == b_id):
                        return

                if self.p2p.check2 and b_id.startswith("000004"):
                    print("pID: %d received block with BlkID: %s at time: %f from pID: %d" %
                          (self.p_id, b_id, time, sender))

                if self.verify_block(b_id, time): # if block is verified
                    # remove block txns from pending list
                    for txn in self.p2p.block_map[b_id].txns:
                        self.rem_txn(txn)
                    # insert the  block node into the tree              
                    is_longest = self.selfish_tree_insert(b_id, time)

                    # forward the block to neighbours
                    for i in range(self.p2p.num_peers):
                        if self.p2p.selfish_adj_mat[self.p_id-1][i]>0 and i+1 != sender:
                            event = self.p2p.Event("rblk", b_id, self.p_id)
                            if(self.p2p.peers[i].fast_slow==1 and self.fast_slow==1):
                                cij = 100
                            else:
                                cij = 5
                            blk_size = max(8*len(self.p2p.block_map[b_id].txns), 8)
                            delay = time+(self.p2p.selfish_adj_mat[self.p_id-1][i]+(blk_size/cij)+np.random.exponential(96/cij))
                            self.p2p.peers[i].add_event(delay, event)
                    # start mining if longest chain formed
                    if is_longest:
                        self.create_block(time)
                else:
                    if self.p2p.check2 and b_id.startswith("000004"):
                        print("INVALID BLOCK!!")
                    pass


        def verify_block(self, b_id, time):
            if self.p2p.check2 and b_id.startswith("000004"):
                print("pID: %d verifying BlkID: %s at time: %f" % (
                    self.p_id, b_id, time))
            block = self.p2p.block_map[b_id]
            if not block.hidden:
                parent_block_node = self.block_node_map[block.prev_b_id]
            else:
                parent_block_node = self.selfish_block_node_map[block.prev_b_id]
            pay_sum = [] # stores total amount payed by each peer in all txns in this block 
            for i in range(self.p2p.num_peers):
                pay_sum.append(0)

            # check that payed sum does not exceed present balance at any point, return false otherwise 
            for t_id in block.txns:
                amt = self.p2p.transaction_map[t_id].amt
                payer_id = self.p2p.transaction_map[t_id].payer
                pay_sum[payer_id-1] += amt
                if parent_block_node.accounts[payer_id-1] < pay_sum[payer_id-1]:
                    if self.p2p.check2 and b_id.startswith("000004"):
                        print("INVALID - pID: %d trying to pay more than its balance of %d" % (
                           payer_id, parent_block_node.accounts[payer_id-1]))
                    return False

            if self.p2p.check2 and b_id.startswith("000004"):
                print("VERIFIED!!")

            return True # iff all checks passed

        # remove from pending txns if present
        def rem_txn(self, t_id):
            try:
                self.pending_txs.remove(t_id)
            except:
                pass

        # start mining a new block
        def create_block(self, time):
            # choose random subset of txns
            ttxns = []
            if len(self.pending_txs) < MAX_BLK_SIZE:
                ttxns = self.pending_txs
            else:
                ttxns = random.sample(self.pending_txs, MAX_BLK_SIZE)

            hidden = False
            if not self.selfish:
                prev_b_id = self.longest[0]
                parent_block_node = self.block_node_map[prev_b_id]
            else:
                prev_b_id= self.selfish_longest[0]
                parent_block_node = self.selfish_block_node_map[prev_b_id]
                hidden = True

            # filtering out invalid txns
            pay_sum = [] # stores total amount payed by each peer in all selected txns
            for i in range(self.p2p.num_peers):
                pay_sum.append(0)

            # check that payed sum does not exceed present balance at any point, remove txn otherwise 
            txns = []
            for t_id in ttxns:
                amt = self.p2p.transaction_map[t_id].amt
                payer_id = self.p2p.transaction_map[t_id].payer
                pay_sum[payer_id-1] += amt
                if parent_block_node.accounts[payer_id-1] >= pay_sum[payer_id-1]:
                    txns.append(t_id)


            self.next_b += 1 # increment number of blks generated by this peer

            b_id = generate_b_id(self.p_id, self.next_b) # generate a blk id
            current_block = self.p2p.Block(
                txns, b_id, prev_b_id, self.p_id, hidden)
            self.p2p.block_map[b_id] = current_block

            # generate POW time
            # !! change
            tk = generate_POW_time(self.Tk)
            # !!

            if self.p2p.check2 and b_id.startswith("000004"):
                print("pID: %d started mining block with BlkID: %s at time: %f, should be broadcast at %f" % (self.p_id,
                    b_id, time, time+tk))

            # add broadcast event at POW time delay to own events queue
            event = self.p2p.Event("bblk", b_id, self.p_id)
            self.events.put((time + tk, event))

        # processes broadcast event
        def broadcast_block(self, b_id, time, hide):
            current_block = self.p2p.block_map[b_id]

            longest = self.longest[0]
            if hide and self.selfish:
                longest = self.selfish_longest[0]

            if (self.selfish and not hide) or longest == current_block.prev_b_id:
                if self.p2p.check2 and b_id.startswith("000004"):
                    print("pID: %d %s broadcasted BlkID: %s at time %f" % (
                        self.p_id, "hide" if hide else "public", b_id, time))

                # receive own block
                self.p2p.block_map[b_id].hidden = hide and self.selfish
                self.receive_block(b_id, time, self.p_id)
            else:
                if self.p2p.check2 and b_id.startswith("000004"):
                    print("pID: %d : BlkID: %s not on longest chain at time %f" % (
                            self.p_id, b_id, time))

        #destroy the tree with its root as the given block
        def destroy_tree(self, block_tree_node):
            for child in block_tree_node.children:
                self.destroy_tree(child)
            old_tree_node = self.selfish_block_node_map.pop(block_tree_node.b_id)
            del old_tree_node

        #update all branch lengths
        def clean_up(self, block_tree_node):
            for child in block_tree_node.children:
                child.length -= 1
                self.clean_up(child)


        #find the head of the longest branch of the hidden tree
        def find_earliest_block(self):
            for child in self.selfish_block_tree_root.children:
                if self.contains_longest(child):
                    return child.b_id
            return -1

        #find if the given node is the leaf of a longest chain
        def contains_longest(self, block_tree_node):
            if block_tree_node.b_id in self.selfish_longest:
                return True
            for child in block_tree_node.children:
                if self.contains_longest(child):
                    return True

            return False


        #send the received alert to its neighbours
        def send_alert(self, sender, time, b_id):
            for i in range(self.p2p.num_peers):
                if self.p2p.selfish_adj_mat[self.p_id-1][i]>0 and i+1 != sender:
                    event = self.p2p.Event("ralt", b_id, self.p_id)
                    cij = 100
                    msg_size = 0
                    delay = time+(self.p2p.selfish_adj_mat[self.p_id-1][i]+(msg_size/cij)+np.random.exponential(96/cij))
                    self.p2p.peers[i].add_event(delay, event)


        #selfish miner receives alert that honest mines have mined a block ans sends this alert to its neighours
        def receive_alert(self, sender, time, b_id, lead, count):
            if b_id == self.latest_alert_b_id:
                return
            self.latest_alert_b_id = b_id
            if count==0:
                self.send_alert(sender, time, b_id)
            earliest_common_block_id = self.find_earliest_block()
            # print("received an alert from pid: %d ecb is: %s"%(sender, earliest_common_block_id))
            if earliest_common_block_id == -1:
                self.destroy_tree(self.selfish_block_tree_root)
                self.selfish_block_tree_root = self.p2p.BlockTree(self.longest[0], 1, self)
                for peer_num in range(self.p2p.num_peers):
                    self.selfish_block_tree_root.accounts.append(0)
                self.selfish_block_node_map[self.longest[0]] = self.selfish_block_tree_root
                self.selfish_longest = [self.longest[0]]
                self.p2p.selfish_visual_trees[self.p_id-1] = Tree()
                self.p2p.selfish_visual_trees[self.p_id-1].create_node("(b_id: %s, time: %f)"%(self.longest[0], time), self.longest[0], data=CompressNode())
                print("p_id: %d    time: %f"%(self.p_id, time))
                self.p2p.selfish_visual_trees[self.p_id-1].show()
                return
            #if lead==2:

            self.broadcast_block(earliest_common_block_id, time, False)
            for child in self.selfish_block_tree_root.children:
                if child.b_id != earliest_common_block_id:
                    # destroy the "non-longest" chains
                    self.destroy_tree(child)
            old_selfish_tree_root = self.selfish_block_node_map.pop(self.selfish_block_tree_root.b_id)
            del old_selfish_tree_root
            self.selfish_block_tree_root = self.selfish_block_node_map[earliest_common_block_id]
            # clean up - update all branch lengths
            self.clean_up(self.selfish_block_tree_root)
            # and remove all the invalid "longest" block nodes
            remove_list = []
            for b_id in self.selfish_longest:
                try:
                    block_tree_node = self.selfish_block_node_map[b_id]
                except:
                    remove_list.append(b_id)
            for rem_id in remove_list:
                self.selfish_longest.remove(rem_id)

            if lead==2:
                self.receive_alert(sender, time, b_id, lead, count+1)


            #if lead!=2:
            self.p2p.selfish_visual_trees[self.p_id-1] = self.p2p.selfish_visual_trees[self.p_id-1].subtree(earliest_common_block_id)
            print("p_id: %d    time: %f"%(self.p_id, time))
            self.p2p.selfish_visual_trees[self.p_id-1].show() 
            # add logic for setting and changing the eraliest_common...
            # and removing the broadcasted block from the hidden blocks
            # add logic for scheduling alert related events

        # event handler, shedules the event to be executed by popping it from the events queue,
        # and invoking the correct handler
        def handle_events(self, time):
            if self.events.empty():
                return
            event_time, event = self.events.get()
            while math.ceil(event_time) == math.ceil(time):
                if(event.type == "gtxn"):
                    self.generate_txn(event.data, event_time)
                if(event.type == "rtxn"):
                    self.receive_txn(event.data, event_time, event.sender)
                if(event.type == "rblk"):
                    self.receive_block(event.data, event_time, event.sender)
                if(event.type == "cblk"):
                    self.create_block(event_time)
                if(event.type == "bblk"):
                    self.broadcast_block(event.data, event_time, True)
                if(event.type == "ralt"):
                    lead = self.selfish_block_node_map[self.selfish_longest[0]].length - self.block_node_map[self.longest[0]].length
                    self.receive_alert(event.sender, event_time, event.data, lead, 0)
                if(event.type == "salt"):
                    self.send_alert(event.sender, event_time, event.data)
                if self.events.empty():
                    return
                event_time, event = self.events.get()
            self.events.put((event_time, event))

    # for connecting peers
    #class to convert each peer into graph node with peer_id and its fast_slow
    class Vertex(object):
        def __init__(self, vertex, fast_slow):
            self.fast_slow = fast_slow
            self.id = vertex
            self.neighbours = {}
            
        def __str__(self) -> str:
            return str(self.id) + ' connected to: ' + str([x.id for x in self.neighbours])
        
        #add the adjacent peers of the peer corresponding to this vertex
        def add_neighbour(self, neighbour, weight):
            if neighbour not in self.neighbours.keys():
                self.neighbours[neighbour] = weight

        #get the adjacent peers of the peer corresponding to this vertex
        def get_connections(self):
            return self.neighbours.keys()
        
        def get_id(self):
            return self.id

        #get the weight of edge between given neughbour and the peer corresponding to this vertex
        def get_weight(self, neighbor):
            return self.neighbours[neighbor]
                              
        def __repr__(self) -> str:
            return str(self.neighbours)
        
    # graph of peers
    class Graph(object):
        def __init__(self, p2p):
            self.vertices_dict = {}
            self.num_vertices = 0
            self.adj_matrix = None
            self.selfish_adj_matrix = None
            self.p2p = p2p
            self.num_edges = 0
            self.in_graph = set()
            self.is_complete = False
            
        def __iter__(self):
            return iter(self.vertices_dict.values())
        
        #add vertex to the graph
        def add_vertex(self, node, fast_slow):
            self.num_vertices = self.num_vertices + 1
            new_vertex = self.p2p.Vertex(node, fast_slow)
            self.vertices_dict[node] = new_vertex
            return new_vertex
        
        #add edge to the graph          
        def add_edge(self, vertex_from, vertex_to, weight):
            if vertex_from not in self.vertices_dict:
                self.add_vertex(vertex_from, 0)
                
            if vertex_to not in self.vertices_dict:
                self.add_vertex(vertex_to, 0)
            
            self.vertices_dict[vertex_from].add_neighbour(self.vertices_dict[vertex_to], weight)
            self.num_edges += 1
        
        #get graph vertices  
        def get_vertices(self):
            return self.vertices_dict.keys() 
        
        # creates a connected graph of peers in which each peer is connected to a random number of peers
        def generate_random_graph(self):
            self.adj_matrix = np.zeros(shape=(self.num_vertices, self.num_vertices), dtype=np.int32)
            self.selfish_adj_matrix = np.zeros(shape=np.shape(self.adj_matrix))
            cg = np.eye(self.num_vertices, dtype=np.int32)
            con = np.ones(shape=(self.num_vertices, self.num_vertices), dtype=np.int32)
            while not ((cg == con).all()):
                i = np.random.randint(0, self.num_vertices)
                j = np.random.randint(0, self.num_vertices)
                if(i!=j):
                    self.adj_matrix[i][j] = 1
                    self.adj_matrix[j][i] = 1
                    cg[i][j] = 1
                    cg[j][i] = 1
                    for x in range(self.num_vertices):
                        if(cg[j][x] == 1):
                            cg[i][x] =1 
                        if(cg[i][x] == 1):
                            cg[j][x] = 1
            for i in range(self.num_vertices):
                for j in range(i, self.num_vertices):
                    if (self.adj_matrix[i][j] == 1):
                        pxy = np.random.uniform(10, 500)
                        self.adj_matrix[i][j] = pxy
                        self.adj_matrix[j][i] = pxy
                        if self.p2p.peers[i].selfish and self.p2p.peers[j].selfish:
                            self.selfish_adj_matrix[i][j] = pxy
                            self.selfish_adj_matrix[j][i] = pxy

            for i in range(self.num_vertices):
                for j in range(i+1, self.num_vertices):
                    if (self.adj_matrix[i][j] == 0):
                        prob = np.random.randint(0, 2)
                        if(prob):
                            pxy = np.random.uniform(10, 500)
                            self.adj_matrix[i][j] = pxy
                            self.adj_matrix[j][i] = pxy
                            if self.p2p.peers[i].selfish and self.p2p.peers[j].selfish:
                                self.selfish_adj_matrix[i][j] = pxy
                                self.selfish_adj_matrix[j][i] = pxy
            return self.adj_matrix, self.selfish_adj_matrix


# print("P2P simulation")

# print("Enter simulation time in milli seconds: ", end="")
# sim_time = int(input())

# print("Enter number of peers: ", end="")
# num_peers = int(input())

# print("Enter number of selfish peers: ", end="")
# num_selfish = int(input())

# print("Enter Tx(mean inter-transaction gap) in milli seconds: ", end="")
# Tx = int(input())

# Tk = []
# for i in range(num_peers-num_selfish):
#     print("Enter Tk(mean POW time) for honest peer k = %d in milli seconds :"%(i+1), end="")
#     Tk.append(int(input()))

# Tk_selfish = []
# for i in range(num_selfish):
#     print("Enter Tk(mean POW time) for selfish peer k = %d in milli seconds :"%(i+1), end="")
#     Tk_selfish.append(int(input()))

# print("Track txn generation, loopless forwarding and latencies?: (Y/N)", end="")
# check1 = input()
# if check1=="Y":
#     print("Will follow TxnID 000001000001")

# print("Track blk creation, broadcast, verification, fork resolution?: (Y/N)", end="")
# check2 = input()
# if check2=="Y":
#     print("Will follow BlkID 000001000001")

# p2p = P2P(num_peers, Tx, Tk, Tk_selfish, num_selfish)
# p2p.run(sim_time, check1=="Y", check2=="Y")

Tk = [900, 1300]
Tk_selfish = [300, 700]
p2p = P2P(4, 100, Tk, Tk_selfish, 2)
p2p.run(5000, False, False)

for i in range(p2p.num_peers):
    print("View the hidden and common blockchain trees for %s peer %d? (Y/N)"%("selfish" if p2p.peers[i].selfish else "honest", i+1))
    response = input()
    if response=="Y":
        print("Compress? (Y/N)")
        cmprs = input()
        if cmprs=="Y":
            print("common tree : \n")
            p2p.visual_trees[i].show(data_property="node")
            print("hidden tree : \n")
            p2p.selfish_visual_trees[i].show(data_property="node")
        else:
            print("common tree : \n")
            p2p.visual_trees[i].show()
            print("hidden tree : \n")
            p2p.selfish_visual_trees[i].show()